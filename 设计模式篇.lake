<!doctype lake><title>设计模式篇</title><meta name="doc-version" content="1" /><meta name="viewport" content="fixed" /><meta name="typography" content="classic" /><meta name="paragraphSpacing" content="relax" /><h2 data-lake-id="ZaFzg" id="ZaFzg"><span data-lake-id="u1a6820d7" id="u1a6820d7" class="lake-fontsize-11">1.</span><span data-lake-id="u7da8d743" id="u7da8d743" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">单例模式有哪几种实现？如何保证线程安全？</span></h2><p data-lake-id="u3d8a6981" id="u3d8a6981"><span data-lake-id="u52cfebe2" id="u52cfebe2">单例模式常见有：饿汉式、懒汉式（线程安全版需要加双重检查锁定）、静态内部类、枚举单例（Java 特有）等几个实现方式。</span></p><ul list="u2d917f4d"><li fid="ucead7b8a" data-lake-id="ub3941c12" id="ub3941c12"><span data-lake-id="ud883527a" id="ud883527a" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">饿汉式：实例在类加载时就创建，线程安全，但如果实例初始化较重或没有被使用会浪费资源。</span></li><li fid="ucead7b8a" data-lake-id="u8932a933" id="u8932a933"><span data-lake-id="ufa04ddbc" id="ufa04ddbc" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">懒汉式：实例在首次访问时创建，节约资源，但需要确保线程安全。</span></li><li fid="ucead7b8a" data-lake-id="u614c264c" id="u614c264c"><span data-lake-id="u963015a6" id="u963015a6" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">双重检查锁定：在懒汉式的基础上优化，直接加锁效率太低，双重检查锁只在第一次检查实例为空时加锁，提高性能。</span></li><li fid="ucead7b8a" data-lake-id="u5284b231" id="u5284b231"><span data-lake-id="ubc51027f" id="ubc51027f" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">静态内部类：利用类加载机制实现懒加载和线程安全，推荐使用。 </span></li><li fid="ucead7b8a" data-lake-id="u9f8b500f" id="u9f8b500f"><span data-lake-id="u7acff04c" id="u7acff04c" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">枚举单例（Java 特有）：通过枚举实现单例，简单且防止反射和序列化攻击。</span></li></ul><p data-lake-id="u49a84a4a" id="u49a84a4a"><span data-lake-id="u397c9018" id="u397c9018" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">如何保证线程安全？</span></p><ul list="u2bbcbc12"><li fid="u5c8caa9e" data-lake-id="u2fb3fc31" id="u2fb3fc31"><span data-lake-id="u14360111" id="u14360111" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">Java：推荐静态内部类或双重检查锁定，配合 volatile。</span></li><li fid="u5c8caa9e" data-lake-id="u6d6fdd43" id="u6d6fdd43"><span data-lake-id="ubf17c900" id="ubf17c900" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">C++：推荐使用 std::call_once 或 mutex 实现线程安全。 </span></li><li fid="u5c8caa9e" data-lake-id="u803c00f1" id="u803c00f1"><span data-lake-id="uf82a0a18" id="uf82a0a18" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">Python：使用 </span><strong><span data-lake-id="uc269fbaf" id="uc269fbaf">new</span></strong><span data-lake-id="ud4d026d4" id="ud4d026d4" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)"> 方法或装饰器实现，配合线程锁确保安全。 </span></li><li fid="u5c8caa9e" data-lake-id="u8e5386c5" id="u8e5386c5"><span data-lake-id="ufbc88bcc" id="ufbc88bcc" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">Go：使用 sync.Once 。</span></li></ul><h2 data-lake-id="BkTqn" id="BkTqn"><span data-lake-id="u2653a586" id="u2653a586">2.</span><span data-lake-id="u4a4ed564" id="u4a4ed564" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">什么是策略模式？一般用在什么场景？</span></h2><p data-lake-id="uf84b000d" id="uf84b000d"><span data-lake-id="uc671f7e6" id="uc671f7e6">策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，让算法独立于使用它的客户端（调用方）而变化。</span></p><p data-lake-id="u76ca7ce8" id="u76ca7ce8"><span data-lake-id="ubce4fd4e" id="ubce4fd4e" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">很多情况下，我们代码里有大量的 if else、switch 等，可以通过使用策略模式，避免大量条件语句的使用，实现算法的分离和独立变化。</span></p><p data-lake-id="u8059860d" id="u8059860d"><span data-lake-id="ud874f6bd" id="ud874f6bd" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">它的主要目的是为了解耦多个策略，并方便调用方在针对不同场景灵活切换不同的策略。</span></p><h3 data-lake-id="urqrX" id="urqrX"><span data-lake-id="uf4b8db00" id="uf4b8db00" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">策略模式的特点:</span></h3><ol list="u46f52062"><li fid="ud99924a8" data-lake-id="uc1c699f3" id="uc1c699f3"><strong><span data-lake-id="u49939d2e" id="u49939d2e">算法封装</span></strong><span data-lake-id="ue4099f68" id="ue4099f68" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：将算法的实现与使用算法的代码分离，通过封装提高代码的灵活性和可扩展性。</span></li><li fid="ud99924a8" data-lake-id="ud283f24b" id="ud283f24b"><strong><span data-lake-id="ue2194008" id="ue2194008">动态替换</span></strong><span data-lake-id="ubc0bc9ac" id="ubc0bc9ac" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：可以在运行时选择和替换算法。</span></li><li fid="ud99924a8" data-lake-id="u7d41cd4a" id="u7d41cd4a"><strong><span data-lake-id="u328f5781" id="u328f5781">遵循开闭原则</span></strong><span data-lake-id="u391da142" id="u391da142" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：新增策略无需修改现有代码。</span></li></ol><h3 data-lake-id="XTfSF" id="XTfSF"><span data-lake-id="u465469f8" id="u465469f8" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">一般用在什么场景?</span></h3><ol list="u1671780f"><li fid="ue87d75f5" data-lake-id="u4518b199" id="u4518b199"><strong><span data-lake-id="u92d12247" id="u92d12247">多种算法可互换</span></strong><span data-lake-id="ubae1b9ec" id="ubae1b9ec" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：需要动态选择算法，例如排序算法的选择。</span></li><li fid="ue87d75f5" data-lake-id="u465dc378" id="u465dc378"><strong><span data-lake-id="u9cb638a9" id="u9cb638a9">避免条件语句</span></strong><span data-lake-id="uf2a65889" id="uf2a65889" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：通过策略模式替代代码中大量的 if-else 或 switch 语句。 </span></li><li fid="ue87d75f5" data-lake-id="u729c6469" id="u729c6469"><strong><span data-lake-id="ub5ed03ed" id="ub5ed03ed">与上下文独立</span></strong><span data-lake-id="u301cdbb8" id="u301cdbb8" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：客户端不需要知道具体的算法实现细节，只需依赖抽象策略。</span></li></ol><h3 data-lake-id="ozJAJ" id="ozJAJ"><span data-lake-id="u0d877c44" id="u0d877c44" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">典型场景:</span></h3><ul list="u71e7ca20"><li fid="u38dfa116" data-lake-id="u0413bb98" id="u0413bb98"><strong><span data-lake-id="u9d660338" id="u9d660338">支付系统</span></strong><span data-lake-id="ue35e3d3f" id="ue35e3d3f" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：支持多种支付方式（如微信、支付宝、信用卡）。</span></li><li fid="u38dfa116" data-lake-id="uf8ef3fe0" id="uf8ef3fe0"><strong><span data-lake-id="u264d4b92" id="u264d4b92">数据压缩</span></strong><span data-lake-id="ub525a075" id="ub525a075" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：提供不同的压缩算法。 </span></li><li fid="u38dfa116" data-lake-id="ub17bff3d" id="ub17bff3d"><strong><span data-lake-id="u85ee7a01" id="u85ee7a01">日志策略</span></strong><span data-lake-id="u6f950122" id="u6f950122" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：根据日志级别动态选择记录策略。</span></li></ul><h2 data-lake-id="zxcIi" id="zxcIi"><span data-lake-id="u031bf38e" id="u031bf38e">3.</span><span data-lake-id="u24b31f17" id="u24b31f17" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">什么是模板方法模式？一般用在什么场景？</span></h2><p data-lake-id="u62eed62e" id="u62eed62e"><span data-lake-id="u8d5ddb26" id="u8d5ddb26">模板方法模式是一种行为型设计模式，它在一个抽象类中定义了一个算法（业务逻辑）的骨架，具体步骤的实现由子类提供，它通过将算法的不变部分放在抽象类中，可变部分放在子类中，达到代码复用和扩展的目的。</span></p><ul list="uadebf47d"><li fid="ufffb6dda" data-lake-id="u52bafca2" id="u52bafca2"><strong><span data-lake-id="u59c9a1d1" id="u59c9a1d1">复用</span></strong><span data-lake-id="u67d0e16e" id="u67d0e16e" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：所有子类可以直接复用父类提供的模板方法，即上面提到的不变的部分。</span></li><li fid="ufffb6dda" data-lake-id="u1a3e6573" id="u1a3e6573"><strong><span data-lake-id="u3fa32592" id="u3fa32592">扩展</span></strong><span data-lake-id="u5669060a" id="u5669060a" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：子类可以通过模板定义的一些扩展点就行不同的定制化实现。</span></li></ul><h3 data-lake-id="kZtQo" id="kZtQo"><span data-lake-id="uef6b5823" id="uef6b5823" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">模板方法模式的特点:</span></h3><ol list="u3b032373"><li fid="u0f3ced8d" data-lake-id="u0fe94fd9" id="u0fe94fd9"><strong><span data-lake-id="ue4374e9b" id="ue4374e9b">算法骨架</span></strong><span data-lake-id="u29966e1e" id="u29966e1e" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：在基类中定义一个算法的固定执行步骤（模板方法），具体实现步骤交给子类完成。</span></li><li fid="u0f3ced8d" data-lake-id="u6d8fbae2" id="u6d8fbae2"><strong><span data-lake-id="ufd37459f" id="ufd37459f">复用代码</span></strong><span data-lake-id="u3c096fdc" id="u3c096fdc" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：子类复用基类中定义的通用逻辑，仅需实现特定步骤。 </span></li><li fid="u0f3ced8d" data-lake-id="u9f165cf7" id="u9f165cf7"><strong><span data-lake-id="u96112e81" id="u96112e81">遵循开闭原则</span></strong><span data-lake-id="u87cebcac" id="u87cebcac" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：基类的骨架逻辑对扩展开放，对修改关闭。</span></li></ol><h3 data-lake-id="uVuta" id="uVuta"><span data-lake-id="uda6cb59d" id="uda6cb59d" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">一般用在什么场景?</span></h3><ol list="u12c33403"><li fid="ub9dae02d" data-lake-id="u4a13a14e" id="u4a13a14e"><strong><span data-lake-id="udec38cb5" id="udec38cb5">定义算法骨架</span></strong><span data-lake-id="ua56608d8" id="ua56608d8" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：有一个固定的流程，但某些步骤需要根据具体情况自定义。 </span></li><li fid="ub9dae02d" data-lake-id="uf16bfbe3" id="uf16bfbe3"><strong><span data-lake-id="u669dbe3f" id="u669dbe3f">复用公共逻辑</span></strong><span data-lake-id="u7d280b25" id="u7d280b25" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：多个子类共享相同的算法结构，仅需重写特定步骤。 </span></li><li fid="ub9dae02d" data-lake-id="u56d1c1d6" id="u56d1c1d6"><strong><span data-lake-id="ufd318fd1" id="ufd318fd1">控制执行顺序</span></strong><span data-lake-id="ud2c53b65" id="ud2c53b65" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：需要对子类执行方法的顺序进行控制时。</span></li></ol><h3 data-lake-id="IPHNR" id="IPHNR"><span data-lake-id="u58f938a7" id="u58f938a7" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">典型场景:</span></h3><ul list="u42df5adf"><li fid="uede84aeb" data-lake-id="uf5a4dede" id="uf5a4dede"><strong><span data-lake-id="u826b034a" id="u826b034a">数据处理流程</span></strong><span data-lake-id="u76d360c4" id="u76d360c4" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">（如读取数据、处理数据、输出结果 ）。</span></li><li fid="uede84aeb" data-lake-id="ue2cc8230" id="ue2cc8230"><strong><span data-lake-id="u1a8a2c68" id="u1a8a2c68">Web请求处理</span></strong><span data-lake-id="u2c343fe0" id="u2c343fe0" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">（如解析请求、处理逻辑、返回响应 ）。</span></li></ul><p data-lake-id="u9bcdf66e" id="u9bcdf66e"><span data-lake-id="u526cd3df" id="u526cd3df" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">在Java中有很多应用场景，例如JdbcTemplate就是使用了模板方法来处理数据库的操作。</span></p><p data-lake-id="u6736a478" id="u6736a478"><span data-lake-id="u75006872" id="u75006872" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">再比如HttpServlet类的service方法也用了模板方法，doGet、doPost等方法都是需要子类实现的。</span></p><h3 data-lake-id="fx5mf" id="fx5mf"><span data-lake-id="uac2a9b65" id="uac2a9b65" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">扩展知识</span></h3><h4 data-lake-id="gDXk4" id="gDXk4"><span data-lake-id="ucf43ffb1" id="ucf43ffb1" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">模板方法模式的组成</span></h4><ol list="ufb11a96b"><li fid="u8089c0b3" data-lake-id="u03aab2d1" id="u03aab2d1"><strong><span data-lake-id="ucfb39f0b" id="ucfb39f0b">抽象类（AbstractClass）</span></strong><span data-lake-id="ua60a5e8d" id="ua60a5e8d" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">：定义模板方法，包含算法的骨架。声明需要子类实现的抽象方法。 </span></li><li fid="u8089c0b3" data-lake-id="ubef6db3d" id="ubef6db3d"><strong><span data-lake-id="uc98c7731" id="uc98c7731">具体类（ConcreteClass）</span></strong><span data-lake-id="u3b051c3a" id="u3b051c3a" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)"> ：实现抽象方法，为算法的某些步骤提供具体实现。 </span></li><li fid="u8089c0b3" data-lake-id="u5ee4f84e" id="u5ee4f84e"><strong><span data-lake-id="uc8c955c6" id="uc8c955c6">模板方法（TemplateMethod）</span></strong><span data-lake-id="ua86385e3" id="ua86385e3" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)"> ：调用一系列步骤方法，构成算法的完整逻辑。</span></li></ol><h2 data-lake-id="a55ZN" id="a55ZN"><span data-lake-id="u5bc654f9" id="u5bc654f9" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">4.谈谈你了解的最常见的几种设计模式，说说他们的应用场景</span></h2><p data-lake-id="ueaf0c616" id="ueaf0c616"><span data-lake-id="u24dafa08" id="u24dafa08">工作中常用的就是单例模式、简单工厂、策略、模板等设计模式。<br /></span><span data-lake-id="u65a6351c" id="u65a6351c">例如，需要确保某个类只有一个实例，并提供一个全局访问点的时候，就能用到单例模式，比如配置管理器或者全局缓存，像常见的数据库连接池等其实都用上了单例模式。<br /></span><span data-lake-id="ub6516c4d" id="ub6516c4d">而且很多时候设计模式在工作中都是组合使用的，比如支付场景，需要对接不同的支付渠道：支付宝、微信、易宝支付、连连支付等等。<br /></span><span data-lake-id="u04c2f1f0" id="u04c2f1f0">不同渠道对应不同策略，天然适合策略模式。</span></p><card type="inline" name="codeblock" value="data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22java%22%2C%22code%22%3A%22public%20interface%20PayService%20%7B%5Cn%20%20%20%20void%20pay(PayDto%20payDto)%3B%5Cn%7D%5Cn%5Cnpublic%20class%20AliPayService%20implements%20PayService%20%7B%5Cn%20%20%20%20public%20void%20pay(PayDto%20payDto)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnpublic%20class%20WechatPayService%20implements%20PayService%20%7B%5Cn%20%20%20%20public%20void%20pay(PayDto%20payDto)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Atrue%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22qVkw1%22%7D"></card><p data-lake-id="u49264889" id="u49264889"><strong><span data-lake-id="u9ea73a69" id="u9ea73a69">并且在不同支付渠道对接过程中会发现大部分流程都是一样的，例如先需要前置的参数检查，然后进行核心的支付逻辑，最后有一些后置的检查等等。这样一致的流程就能抽象成一个模板方法，让不同渠道的实现类都继承它，这就运用了模板方法。</span></strong></p><p data-lake-id="uc9d87d20" id="uc9d87d20"><strong><span data-lake-id="uc569a324" id="uc569a324">​</span></strong><br></p><card type="inline" name="codeblock" value="data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22markdown%22%2C%22code%22%3A%22public%20abstract%20class%20AbstractPayService%20implements%20PayService%20%7B%5Cn%20%20%20%20%5Cn%20%20%20%20%2F%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%5Cn%20%20%20%20%40Override%5Cn%5Ctpublic%20void%20pay(PayDto%20payDto)%20%7B%5Cn%20%20%20%20%20%20%20%20paramValidate(payDto)%3B%5Cn%20%20%20%20%20%20%20%20doPay(payDto)%3B%5Cn%20%20%20%20%20%20%20%20afterProcess()%5Cn%5Ct%7D%5Cn%5Cn%5Ctprivate%20void%20paramValidate(PayDto%20payDto)%20%7B%5Cn%20%20%20%20%20%20%20%20.....%5Cn%5Ct%7D%5Cn%5Cn%5Ctprivate%20void%20afterProcess()%20%7B%5Cn%20%20%20%20%20%20%20%20.....%5Cn%5Ct%7D%5Cn%5Cn%20%20%20%20%2F%2F%20%E4%B8%8D%E5%90%8C%E6%94%AF%E4%BB%98%E6%B8%A0%E9%81%93%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%5Cn%5Ctpublic%20abstract%20void%20doPay(PayDto%20payDto)%3B%5Cn%7D%5Cn%5Cnpublic%20class%20AliPayService%20extends%20AbstractPayService%20%7B%5Cn%5Ctpublic%20void%20doPay(PayDto%20payDto)%20%7B%5Cn%20%20%20%20%20%20%2F%2F%20....%5Cn%5Ct%7D%5Cn%7D%5Cnpublic%20class%20WechatPayService%20extends%20AbstractPayService%20%7B%5Cn%5Ctpublic%20void%20doPay(PayDto%20payDto)%20%7B%5Cn%20%20%20%20%20%20%2F%2F%20....%5Cn%5Ct%7D%5Cn%7D%5Cn%22%2C%22autoWrap%22%3Atrue%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22fontSize%22%3A14%2C%22customStyle%22%3A%5B%5D%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22Vp9Hr%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D"></card><p data-lake-id="u7709cb5c" id="u7709cb5c"><span data-lake-id="ud6527988" id="ud6527988">还有个简单工厂模式可以用在选择支付渠道的时候，创建一个支付工厂方法，传入了 ALIPAY 得到支付宝的支付实现类，传入 WECHAT 得到微信的实现类，这不就是工厂方法吗？</span></p><card type="inline" name="codeblock" value="data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22java%22%2C%22code%22%3A%22%40Component%5Cnpublic%20class%20PayServiceFactory%20%7B%5Cn%5Cn%20%20%20%20%40Resource%5Cn%20%20%20%20private%20Map%3CString%2C%20PayService%3E%20payServiceMap%3B%5Cn%5Cn%20%20%20%20public%20PayService%20getPayService(String%20channel)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20payServiceMap.get(channel)%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Atrue%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22FCd9z%22%7D"></card><h2 data-lake-id="LcdIh" id="LcdIh"><span data-lake-id="uec325136" id="uec325136" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">5.你认为好的代码应该是什么样的？</span></h2><p data-lake-id="u0bf23e96" id="u0bf23e96"><span data-lake-id="ua251a9f6" id="ua251a9f6">好的代码就像一本清晰易懂的书，别人能快速看懂它的内容。它简洁、整洁，做的事情不多也不少，能够有效地解决问题。每个部分职责明确，修改或扩展时不会影响到其他部分，就像拼图一样，每个模块都是独立的、紧密配合的。而且，它能很好地处理各种意外情况，不会轻易出错。最终，别人看了你的代码，能够快速理解，并且能在需要时方便地修改或优化。</span></p><h3 data-lake-id="oOyfu" id="oOyfu"><span data-lake-id="uf504c032" id="uf504c032">扩展知识</span></h3><h4 data-lake-id="kGvK7" id="kGvK7"><span data-lake-id="u5b066742" id="u5b066742">清晰易懂</span></h4><p data-lake-id="u82185bf4" id="u82185bf4"><span data-lake-id="u92e86049" id="u92e86049">代码应该简洁、直观，让其他开发者能快速理解。变量和函数的命名要有意义，能够准确反映其功能和用途。避免使用晦涩的术语或者复杂的逻辑，使代码易于阅读和维护。</span></p><h4 data-lake-id="tdnEM" id="tdnEM"><span data-lake-id="u71ab4da6" id="u71ab4da6">高内聚低耦合</span></h4><p data-lake-id="uede9a233" id="uede9a233"><span data-lake-id="u8c42ca56" id="u8c42ca56">高内聚指的是代码模块内部功能集中，每个模块都有单一的责任；低耦合指的是不同模块之间的依赖关系尽量松散。这样有助于代码的复用性和可维护性。修改一个模块时，其他模块受到的影响较小。</span></p><h4 data-lake-id="ZgqzP" id="ZgqzP"><span data-lake-id="u7d0f829a" id="u7d0f829a">可测试</span></h4><p data-lake-id="u98163839" id="u98163839"><span data-lake-id="uf2ebd7fe" id="uf2ebd7fe">好的代码通常是容易测试的。每个功能模块应该尽量设计为独立的、可验证的单元。编写单元测试用例时，能够确保代码的正确性并发现潜在问题。</span></p><h4 data-lake-id="zpHd4" id="zpHd4"><span data-lake-id="ue061241f" id="ue061241f">易于扩展和修改</span></h4><p data-lake-id="u72e18d9f" id="u72e18d9f"><span data-lake-id="u95a7231b" id="u95a7231b">代码应该具备一定的灵活性，能够在不破坏现有功能的情况下，方便地进行扩展和修改。设计时考虑到未来可能的需求变化，避免过于僵化的实现。</span></p><h4 data-lake-id="vuihq" id="vuihq"><span data-lake-id="u2144d013" id="u2144d013">遵循设计原则</span></h4><p data-lake-id="u5e3f2f80" id="u5e3f2f80"><span data-lake-id="u077915f9" id="u077915f9">遵循如 SOLID 原则、DRY（不要重复自己）、KISS（保持简单）、YAGNI（你并不需要它）等软件设计原则。使得代码在结构上清晰，逻辑上简洁，避免过度设计和不必要的复杂性。</span></p><p data-lake-id="u4a09e0d0" id="u4a09e0d0"><span data-lake-id="uc664a420" id="uc664a420">​</span><br></p><h4 data-lake-id="oaQVJ" id="oaQVJ"><span data-lake-id="u923233e2" id="u923233e2">性能优良</span></h4><p data-lake-id="u26bfebb4" id="u26bfebb4"><span data-lake-id="ub9a3f6d8" id="ub9a3f6d8">在保证功能正确性的前提下，代码应该具备足够的性能优化。比如选择合适的算法、数据结构和缓存策略，避免不必要的资源浪费。</span></p><h4 data-lake-id="xzcMC" id="xzcMC"><span data-lake-id="u8cafc201" id="u8cafc201">良好的错误处理</span></h4><p data-lake-id="u155ecf6c" id="u155ecf6c"><span data-lake-id="u9c887a8a" id="u9c887a8a">好的代码应该能够处理各种预期之外的情况，提供清晰的错误信息，避免系统崩溃。错误处理应该精确且易于调试，能够帮助开发者定位问题。</span></p><h4 data-lake-id="sehyY" id="sehyY"><span data-lake-id="u7993bb9b" id="u7993bb9b">规范和一致性</span></h4><p data-lake-id="ue70c7dec" id="ue70c7dec"><span data-lake-id="u5b75368c" id="u5b75368c">代码风格应统一，遵循团队的编码规范或行业标准。无论是缩进、命名约定还是注释风格，保持一致有助于团队协作和代码审查。</span></p><h4 data-lake-id="cfvIB" id="cfvIB"><span data-lake-id="u99b2b8a7" id="u99b2b8a7">注释和文档</span></h4><p data-lake-id="u1f1a1926" id="u1f1a1926"><span data-lake-id="ud08f9a5a" id="ud08f9a5a">虽然代码应该尽量做到自解释，但对于复杂的逻辑或非常规的实现方法，适当的注释是必要的。此外，代码的文档也能帮助其他开发者更好地理解和使用该代码。</span></p><h4 data-lake-id="zUMCI" id="zUMCI"><span data-lake-id="uf8938caf" id="uf8938caf">保持简单</span></h4><p data-lake-id="ufcd6deb9" id="ufcd6deb9"><span data-lake-id="uc2b8b9d9" id="uc2b8b9d9">简单的代码通常是最好的代码。复杂的解决方案往往会带来更多的潜在问题和维护成本。应当避免过度工程化，尽量用简单、直观的方式解决问题。</span></p><h2 data-lake-id="YGQHm" id="YGQHm"><span data-lake-id="uaa5709fa" id="uaa5709fa" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">6.工厂模式和抽象工厂模式有什么区别？、</span></h2><p data-lake-id="u58c0aa55" id="u58c0aa55"><span data-lake-id="uc687ede2" id="uc687ede2">工厂模式关注的是创建单一类型对象，定义一个抽象方法，由子类实现具体对象的实例化。<br /></span><span data-lake-id="u9f37fe4d" id="u9f37fe4d">抽象工厂模式关注的是创建一族相关对象，提供一个接口来创建一组相关的或互相依赖的对象，而无需指定它们的具体类。</span></p><h3 data-lake-id="jHBJP" id="jHBJP"><span data-lake-id="ue67d68bc" id="ue67d68bc" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">扩展知识</span></h3><h4 data-lake-id="v8lq9" id="v8lq9"><span data-lake-id="u561b596d" id="u561b596d" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">进一步理解工厂模式和抽象工厂模式</span></h4><p data-lake-id="ub9fcb78e" id="ub9fcb78e"><span data-lake-id="u9b40368e" id="u9b40368e" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">工厂方法模式定义了一个创建对象的抽象方法，一个具体的工厂类负责生产一种产品，如果需要添加新的产品，仅需新增对应的具体工厂类而不需要修改原有的代码实现。<br /></span><span data-lake-id="u4eb03e97" id="u4eb03e97" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">我们来看个例子，假设有一个产品 Product，以及它的具体实现 ConcreteProduct，我们使用工厂方法模式来创建 ConcreteProduct:</span></p><p data-lake-id="u37d15462" id="u37d15462"><span data-lake-id="uc419a0c1" id="uc419a0c1" class="lake-fontsize-11" style="color: rgba(0, 0, 0, 0.88)">​</span><br></p><card type="inline" name="codeblock" value="data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22markdown%22%2C%22code%22%3A%22%2F%2F%20%E4%BA%A7%E5%93%81%E6%8E%A5%E5%8F%A3%5Cnpublic%20interface%20Product%20%7B%5Cn%20%20%20%20void%20use()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81%E5%AE%9E%E7%8E%B0%5Cnpublic%20class%20ConcreteProduct%20implements%20Product%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20use()%20%7B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Using%20ConcreteProduct%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%B7%A5%E5%8E%82%E6%8E%A5%E5%8F%A3%5Cnpublic%20abstract%20class%20Factory%20%7B%5Cn%20%20%20%20public%20abstract%20Product%20createProduct()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%82%E5%AE%9E%E7%8E%B0%5Cnpublic%20class%20ConcreteFactory%20extends%20Factory%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20Product%20createProduct()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20new%20ConcreteProduct()%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E4%BA%A7%E5%93%81%5Cnpublic%20class%20Client%20%7B%5Cn%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%5Cn%20%20%20%20%20%20%20%20Factory%20factory%20%3D%20new%20ConcreteFactory()%3B%5Cn%20%20%20%20%20%20%20%20Product%20product%20%3D%20factory.createProduct()%3B%5Cn%20%20%20%20%20%20%20%20product.use()%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22autoWrap%22%3Atrue%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22fontSize%22%3A14%2C%22customStyle%22%3A%5B%5D%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22M0uVb%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D"></card><p data-lake-id="uce6de0c6" id="uce6de0c6"><span data-lake-id="u706f76d4" id="u706f76d4" style="color: rgb(28, 31, 35)">而抽象工厂提供一个创建一系列相关或相互依赖对象的接口，简单来说不是仅生产一个产品，而是一个系列产品。听起来可能有点抽象，我们还是看一下例子。 假设我们有两个产品 ProductA 和 ProductB，以及它们的具体实现 ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2，我们使用抽象工厂模式来创建这些相关的产品： </span></p><p data-lake-id="ub48febf8" id="ub48febf8"><span data-lake-id="u9847b22d" id="u9847b22d" style="color: rgb(28, 31, 35)"><br /><br /></span></p><card type="inline" name="codeblock" value="data:%7B%22search%22%3A%22%22%2C%22mode%22%3A%22markdown%22%2C%22code%22%3A%22%5Cn%2F%2F%20%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81A%5Cnpublic%20interface%20ProductA%20%7B%5Cn%20%20%20%20void%20use()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81A1%5Cnpublic%20class%20ConcreteProductA1%20implements%20ProductA%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20use()%20%7B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Using%20ConcreteProductA1%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81A2%5Cnpublic%20class%20ConcreteProductA2%20implements%20ProductA%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20use()%20%7B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Using%20ConcreteProductA2%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81B%5Cnpublic%20interface%20ProductB%20%7B%5Cn%20%20%20%20void%20eat()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81B1%5Cnpublic%20class%20ConcreteProductB1%20implements%20ProductB%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20eat()%20%7B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Eating%20ConcreteProductB1%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81B2%5Cnpublic%20class%20ConcreteProductB2%20implements%20ProductB%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20eat()%20%7B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Eating%20ConcreteProductB2%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%5Cnpublic%20interface%20AbstractFactory%20%7B%5Cn%20%20%20%20ProductA%20createProductA()%3B%5Cn%20%20%20%20ProductB%20createProductB()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%821%5Cnpublic%20class%20ConcreteFactory1%20implements%20AbstractFactory%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20ProductA%20createProductA()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20new%20ConcreteProductA1()%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20ProductB%20createProductB()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20new%20ConcreteProductB1()%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%822%5Cnpublic%20class%20ConcreteFactory2%20implements%20AbstractFactory%20%7B%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20ProductA%20createProductA()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20new%20ConcreteProductA2()%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20ProductB%20createProductB()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20new%20ConcreteProductB2()%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E4%BA%A7%E5%93%81%5Cnpublic%20class%20Client%20%7B%5Cn%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%5Cn%20%20%20%20%20%20%20%20AbstractFactory%20factory1%20%3D%20new%20ConcreteFactory1()%3B%5Cn%20%20%20%20%20%20%20%20ProductA%20productA1%20%3D%20factory1.createProductA()%3B%5Cn%20%20%20%20%20%20%20%20ProductB%20productB1%20%3D%20factory1.createProductB()%3B%5Cn%20%20%20%20%20%20%20%20productA1.use()%3B%5Cn%20%20%20%20%20%20%20%20productB1.eat()%3B%5Cn%5Cn%20%20%20%20%20%20%20%20AbstractFactory%20factory2%20%3D%20new%20ConcreteFactory2()%3B%5Cn%20%20%20%20%20%20%20%20ProductA%20productA2%20%3D%20factory2.createProductA()%3B%5Cn%20%20%20%20%20%20%20%20ProductB%20productB2%20%3D%20factory2.createProductB()%3B%5Cn%20%20%20%20%20%20%20%20productA2.use()%3B%5Cn%20%20%20%20%20%20%20%20productB2.eat()%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%22%2C%22autoWrap%22%3Atrue%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22fontSize%22%3A14%2C%22customStyle%22%3A%5B%5D%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22i3CLD%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D"></card><p data-lake-id="u78ad30df" id="u78ad30df"><span data-lake-id="u4e92cf95" id="u4e92cf95">代码虽然很多，但是看下来应该很清晰，抽象工厂就是打包式的创建系列对象，等于帮我们搭配好了，屏蔽关联对象的一些创建细节。</span></p><p data-lake-id="uf36a7350" id="uf36a7350"><span data-lake-id="u1c5fda2b" id="u1c5fda2b">简单总结一下</span></p><h3 data-lake-id="enNuI" id="enNuI"><span data-lake-id="u604b06c6" id="u604b06c6">工厂方法模式：</span></h3><ul list="u4fee6b53"><li fid="u95c1cedd" data-lake-id="u94a627a7" id="u94a627a7"><span data-lake-id="u0e973cfa" id="u0e973cfa">关注创建单一产品对象。</span></li><li fid="u95c1cedd" data-lake-id="uec5f7ae5" id="uec5f7ae5"><span data-lake-id="u58298bee" id="u58298bee">使用子类来决定创建哪个具体产品。 </span></li><li fid="u95c1cedd" data-lake-id="u165fc4c8" id="u165fc4c8"><span data-lake-id="uf2ba7c53" id="uf2ba7c53">扩展性较好，新增产品时只需增加新的工厂子类。</span></li></ul><h3 data-lake-id="SPyAs" id="SPyAs"><span data-lake-id="u395a5fb1" id="u395a5fb1">抽象工厂模式：</span></h3><ul list="udf85393a"><li fid="u085cfd9c" data-lake-id="u230389bf" id="u230389bf"><span data-lake-id="ubf9fed47" id="ubf9fed47">关注创建一系列相关或相互依赖的产品对象。</span></li><li fid="u085cfd9c" data-lake-id="ud3e5554e" id="ud3e5554e"><span data-lake-id="u219bf5c8" id="u219bf5c8">提供一个接口，用于创建多个产品族的对象。 </span></li><li fid="u085cfd9c" data-lake-id="u54d41a60" id="u54d41a60"><span data-lake-id="u979b8dc8" id="u979b8dc8">增加新的产品族较为容易，但增加新产品类型较为困难。（比如要加个 createProductC，所有实现具体工厂的代码都得改）</span></li></ul><p data-lake-id="udb45dde4" id="udb45dde4"><br></p>
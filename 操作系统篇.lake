<!doctype lake><title>操作系统篇</title><meta name="doc-version" content="1" /><meta name="viewport" content="fixed" /><meta name="typography" content="classic" /><meta name="paragraphSpacing" content="relax" /><h2 data-lake-id="u7h0r" id="u7h0r" data-lake-index-type="2"><span data-lake-id="ue457777e" id="ue457777e" style="color: rgba(0, 0, 0, 0.88)">什么是用户态和内核态？</span></h2><p data-lake-id="u6fa1d5bd" id="u6fa1d5bd"><span data-lake-id="ubaab0629" id="ubaab0629"><br /></span><span data-lake-id="u2fb90572" id="u2fb90572">用户态（User Mode）和内核态（Kernel Mode）是操作系统中的两种运行模式，用于区分应用程序与操作系统内核的操作权限。<br /></span><span data-lake-id="u03a7bcc0" id="u03a7bcc0">两者的区别在于权限级别</span></p><ul list="uea0bc6f0"><li fid="u6bd45845" data-lake-id="uafeef2a9" id="uafeef2a9"><span data-lake-id="uf75254bf" id="uf75254bf" style="color: rgba(0, 0, 0, 0.88)">用户态：应用程序在用户态下运行，权限较低，不能直接访问硬件或进行特权操作。应用程序需要通过系统调用与内核进行通信，由内核代为执行敏感操作。用户态的优势是安全性高，即使程序出现问题也不会影响操作系统的稳定性。</span></li><li fid="u6bd45845" data-lake-id="u12dc221e" id="u12dc221e"><span data-lake-id="u86c34ad5" id="u86c34ad5" style="color: rgba(0, 0, 0, 0.88)">内核态：内核态是操作系统内核运行的模式，具有最高的权限，可以直接访问硬件资源和执行各种特权操作（如内存管理、进程调度）。当程序执行系统调用或硬件中断时，操作系统会将其切换到内核态。</span></li></ul><p data-lake-id="u65c86dea" id="u65c86dea"><span data-lake-id="u1e8ee1b3" id="u1e8ee1b3" style="color: rgba(0, 0, 0, 0.88)">扩展知识<br /></span><span data-lake-id="ub24e4e6f" id="ub24e4e6f" style="color: rgba(0, 0, 0, 0.88)">类比理解用户态与内核态<br /></span><span data-lake-id="u9b78615b" id="u9b78615b" style="color: rgba(0, 0, 0, 0.88)">可以将用户态和内核态的关系类比为驾驶员和引擎的关系：</span></p><ul list="ucd3f05fe"><li fid="uf82e8595" data-lake-id="ue657c43f" id="ue657c43f"><span data-lake-id="u143cf663" id="u143cf663" style="color: rgba(0, 0, 0, 0.88)">驾驶员（用户态程序）可以操控方向盘、油门，但无法直接控制发动机的内部运作。</span></li><li fid="uf82e8595" data-lake-id="ue09433c3" id="ue09433c3"><span data-lake-id="ud53a0e92" id="ud53a0e92" style="color: rgba(0, 0, 0, 0.88)">发动机的内部运作（内核态）由专门的控制系统来处理，驾驶员通过踩油门或刹车（系统调用）间接控制引擎。这种设计保证了即使驾驶员做出不当操作，车辆的核心部件也能保持正常运转。</span></li></ul><p data-lake-id="u54468686" id="u54468686"><span data-lake-id="u127a8f3e" id="u127a8f3e" style="color: rgba(0, 0, 0, 0.88)">操作系统的保护模式<br /></span><span data-lake-id="u2524cf78" id="u2524cf78" style="color: rgba(0, 0, 0, 0.88)">操作系统中通常采用保护模式（Protection Mode）来实现用户态和内核态的区分。现代CPU（如x86架构）支持多级特权模式（Ring 0到Ring 3），Ring 0对应内核态，具有最高权限，Ring 3对应用户态，具有最低权限。操作系统利用这些模式来保护内核代码和数据，防止用户态程序的非法访问。</span></p><h3 data-lake-id="lZClv" id="lZClv" data-lake-index-type="2"><span data-lake-id="ucfc177ed" id="ucfc177ed" style="color: rgba(0, 0, 0, 0.88)">微内核与宏内核的区别</span></h3><ul list="ueafb8146"><li fid="u35afc259" data-lake-id="u4dac117c" id="u4dac117c"><strong><span data-lake-id="ue27d5e12" id="ue27d5e12">微内核（Microkernel）</span></strong><span data-lake-id="u3e497a93" id="u3e497a93" style="color: rgba(0, 0, 0, 0.88)">：尽量将大部分操作系统功能移至用户态，仅保留最基础的功能（如进程间通信、内存管理）在内核态中。优点是系统更稳定、模块化，但切换频繁，性能不如宏内核。</span></li><li fid="u35afc259" data-lake-id="ubb52625f" id="ubb52625f"><strong><span data-lake-id="u2e751703" id="u2e751703">宏内核（Monolithic Kernel）</span></strong><span data-lake-id="u6fa59576" id="u6fa59576" style="color: rgba(0, 0, 0, 0.88)">：大部分操作系统服务在内核态中运行，包括文件系统、驱动程序等。优点是性能高，因为减少了用户态与内核态之间的切换，但可能增加系统的复杂性和维护难度。</span></li></ul><h3 data-lake-id="IfYbX" id="IfYbX" data-lake-index-type="2"><span data-lake-id="u513d181e" id="u513d181e" style="color: rgba(0, 0, 0, 0.88)">上下文切换的机制</span></h3><p data-lake-id="u8f0c6c93" id="u8f0c6c93"><span data-lake-id="uda993a33" id="uda993a33" style="color: rgba(0, 0, 0, 0.88)">在用户态和内核态之间切换时，操作系统会执行上下文切换，包括保存当前进程的寄存器、状态和堆栈等信息，并加载内核态的状态以处理系统调用。上下文切换的成本较高，所以优化系统性能时，需要减少不必要的系统调用和态切换。</span></p><h3 data-lake-id="xZLE8" id="xZLE8" data-lake-index-type="2"><span data-lake-id="u0fe80144" id="u0fe80144" style="color: rgba(0, 0, 0, 0.88)">设计内核态和用户态的原因</span></h3><ul list="u4d72b16d"><li fid="ub6d754b1" data-lake-id="u1c23e0b7" id="u1c23e0b7"><strong><span data-lake-id="u224df77c" id="u224df77c">安全性</span></strong><span data-lake-id="u7cce1f11" id="u7cce1f11" style="color: rgba(0, 0, 0, 0.88)">：用户态和内核态的划分确保了普通应用程序无法直接访问硬件资源或执行敏感操作，避免了程序或用户恶意操作对系统核心的破坏。例如，防止应用程序随意读写内存或控制硬件设备，保护了操作系统和其他应用的安全。 </span></li><li fid="ub6d754b1" data-lake-id="u0c5d9976" id="u0c5d9976"><strong><span data-lake-id="ua1bae29c" id="ua1bae29c">稳定性</span></strong><span data-lake-id="u0973e521" id="u0973e521" style="color: rgba(0, 0, 0, 0.88)">：通过在内核态中运行关键系统服务（如内存管理、文件系统、设备驱动等），操作系统可以对资源进行集中管理和保护。如果某个应用程序崩溃，只会影响用户态中的进程，不会影响到整个系统。 </span></li><li fid="ub6d754b1" data-lake-id="ubb518d2f" id="ubb518d2f"><strong><span data-lake-id="ubd4fb3ae" id="ubd4fb3ae">访问控制</span></strong><span data-lake-id="u18020a0c" id="u18020a0c" style="color: rgba(0, 0, 0, 0.88)">：通过设置不同的权限级别，操作系统能够更好地控制对资源的访问。只有在内核态下，操作系统才有权对硬件资源进行操作，而用户态程序必须通过系统调用请求内核服务，这种设计确保了对系统资源的统一管理。 </span></li><li fid="ub6d754b1" data-lake-id="u86495e57" id="u86495e57"><strong><span data-lake-id="u5943f659" id="u5943f659">性能优化</span></strong><span data-lake-id="u15926346" id="u15926346" style="color: rgba(0, 0, 0, 0.88)">：虽然用户态和内核态的切换有一定开销，但这种设计可以减少用户程序直接操作硬件带来的复杂性，避免频繁的资源争夺和死锁问题，从而提升系统的整体性能。</span></li></ul><h2 data-lake-id="hvIHC" id="hvIHC" data-lake-index-type="2"><span data-lake-id="ub6c13150" id="ub6c13150" style="color: rgba(0, 0, 0, 0.88)">到底什么是 Reactor？</span></h2><p data-lake-id="u319a1857" id="u319a1857"><span data-lake-id="u19f5bbb2" id="u19f5bbb2">Reactor 是一种用于处理并发I/O事件的设计模式，特别适合于网络服务器的开发。它通过事件驱动机制和非阻塞I/O，能够高效地处理大量并发连接。</span></p><p data-lake-id="uc5555705" id="uc5555705"><span data-lake-id="uc34034b5" id="uc34034b5" style="color: rgba(0, 0, 0, 0.88)">Reactor模式的核心思想是将I/O事件与相应的处理程序解耦，并通过事件分发器（Event Demultiplexer）来管理事件和响应操作。</span></p><h3 data-lake-id="f6tGe" id="f6tGe" data-lake-index-type="2"><span data-lake-id="u42a8f866" id="u42a8f866" style="color: rgba(0, 0, 0, 0.88)">Reactor的工作方式：</span></h3><ul list="u0845d77a"><li fid="u34461b7a" data-lake-id="u8cb26cf7" id="u8cb26cf7"><strong><span data-lake-id="u02300b87" id="u02300b87">事件驱动</span></strong><span data-lake-id="u6976b217" id="u6976b217" style="color: rgba(0, 0, 0, 0.88)">：Reactor通过监听多个事件源（如Socket连接、读写事件），在有事件发生时调用对应的处理程序（Handler）。</span></li><li fid="u34461b7a" data-lake-id="u467a767b" id="u467a767b"><strong><span data-lake-id="ubbfe5502" id="ubbfe5502">非阻塞I/O</span></strong><span data-lake-id="u945f9c1f" id="u945f9c1f" style="color: rgba(0, 0, 0, 0.88)">：使用非阻塞I/O模型，Reactor能够在单个或少数线程中高效处理大量I/O操作，避免了线程的频繁切换。 </span></li><li fid="u34461b7a" data-lake-id="u312215e3" id="u312215e3"><strong><span data-lake-id="uca3ce63c" id="uca3ce63c">事件分发与处理</span></strong><span data-lake-id="u9029370e" id="u9029370e" style="color: rgba(0, 0, 0, 0.88)">：Reactor会将收到的事件（如连接到达、数据可读、数据可写）分发给相应的事件处理器，处理器对事件进行处理。</span></li></ul><h2 data-lake-id="f4Ah1" id="f4Ah1" data-lake-index-type="2"><span data-lake-id="u2c8e90c1" id="u2c8e90c1" style="color: rgba(0, 0, 0, 0.88); background-color: rgb(250, 250, 250)">为什么要有虚拟内存？</span></h2><p data-lake-id="u39de5834" id="u39de5834"><br></p><h3 data-lake-id="yz947" id="yz947" data-lake-index-type="2"><span data-lake-id="u87035135" id="u87035135">回答重点</span></h3><p data-lake-id="ud55fcf51" id="ud55fcf51"><span data-lake-id="ufb124bd3" id="ufb124bd3">虚拟内存的主要作用是提升系统效率和简化内存管理。</span></p><ol list="u8e7440cb"><li fid="u03b7b81b" data-lake-id="u45636166" id="u45636166"><strong><span data-lake-id="u8fed6020" id="u8fed6020">内存扩展能力</span></strong><span data-lake-id="uf3fd5689" id="uf3fd5689">：</span></li></ol><ul list="u8e7440cb" data-lake-indent="1"><li fid="u7975e158" data-lake-id="u216d9333" id="u216d9333"><span data-lake-id="uc48f02a0" id="uc48f02a0">虚拟内存允许程序运行在比实际物理内存大的地址空间上。即使物理内存不足，系统也可以通过交换（swapping）将不常用的内存页移到磁盘中，使得多个程序能够同时运行。</span></li></ul><ol list="u8e7440cb" start="2"><li fid="u03b7b81b" data-lake-id="ua316e804" id="ua316e804"><strong><span data-lake-id="u8c9dc438" id="u8c9dc438">进程隔离</span></strong><span data-lake-id="u4ea81321" id="u4ea81321">：</span></li></ol><ul list="u8e7440cb" data-lake-indent="1"><li fid="u2f25d6af" data-lake-id="u901c02e4" id="u901c02e4"><span data-lake-id="u0e867d0e" id="u0e867d0e">每个进程拥有独立的虚拟地址空间，防止进程间的内存访问冲突，提高系统稳定性和安全性。</span></li><li fid="u2f25d6af" data-lake-id="uc9e67e7c" id="uc9e67e7c"><span data-lake-id="uc1dda9f4" id="uc1dda9f4">使用虚拟内存，操作系统可以通过页面表设置访问权限，防止非法访问。</span></li></ul><ol list="u8e7440cb" start="3"><li fid="u03b7b81b" data-lake-id="u142cb7d4" id="u142cb7d4"><strong><span data-lake-id="ue76d6a9c" id="ue76d6a9c">简化内存管理</span></strong><span data-lake-id="u3848d071" id="u3848d071">：</span></li></ol><ul list="u8e7440cb" data-lake-indent="1"><li fid="u1002d1a7" data-lake-id="ud9a675c0" id="ud9a675c0"><span data-lake-id="ud890a814" id="ud890a814">操作系统可以更灵活地分配和回收内存，无需手动考虑物理内存布局问题。</span></li><li fid="u1002d1a7" data-lake-id="u269e0d85" id="u269e0d85"><span data-lake-id="u31c1bb42" id="u31c1bb42">虚拟内存可以将程序逻辑地址与物理地址解耦。</span></li></ul><h3 data-lake-id="r2qhq" id="r2qhq" data-lake-index-type="2"><span data-lake-id="ucc909e05" id="ucc909e05">扩展知识</span></h3><h4 data-lake-id="l4I6A" id="l4I6A" data-lake-index-type="2"><span data-lake-id="u01971b72" id="u01971b72">虚拟内存的执行原理</span></h4><ol list="u3159db82"><li fid="u4f05c0a6" data-lake-id="u3ced4921" id="u3ced4921"><strong><span data-lake-id="u4f8ca206" id="u4f8ca206">逻辑地址与物理地址的映射</span></strong><span data-lake-id="uff8e1242" id="uff8e1242">：<br /></span><span data-lake-id="u39a4fd4b" id="u39a4fd4b">每个进程生成的逻辑地址需要经过地址翻译，映射到实际的物理内存地址。地址翻译由硬件中的内存管理单元（MMU）完成。<br /></span><span data-lake-id="u7d0746bf" id="u7d0746bf">具体过程是：</span></li></ol><ol list="u3159db82" data-lake-indent="1"><li fid="u037d2252" data-lake-id="udb1858a3" id="udb1858a3"><span data-lake-id="uf1b0ad81" id="uf1b0ad81">CPU生成逻辑地址。</span></li><li fid="u037d2252" data-lake-id="udcf70c71" id="udcf70c71"><span data-lake-id="ucc4c2f0e" id="ucc4c2f0e">MMU根据页表将逻辑地址分解为页号和页内偏移量。 </span></li><li fid="u037d2252" data-lake-id="uc634fad8" id="uc634fad8"><span data-lake-id="u17771e73" id="u17771e73">MMU查找页表，找到对应页号的物理地址。 </span></li><li fid="u037d2252" data-lake-id="u0f17cc43" id="u0f17cc43"><span data-lake-id="udc9dbb57" id="udc9dbb57">合并物理页号与偏移量，生成最终的物理地址。 <br /></span><span data-lake-id="ud74586ca" id="ud74586ca">如果页表项未命中（Page Fault），操作系统将从磁盘中加载相应的页面。</span></li></ol><ol list="u3159db82" start="2"><li fid="u4f05c0a6" data-lake-id="u982d287f" id="u982d287f"><strong><span data-lake-id="ufe48ef78" id="ufe48ef78">页表管理与多级页表</span></strong><span data-lake-id="u67493f29" id="u67493f29">：<br /></span><span data-lake-id="u5619872b" id="u5619872b">页表记录逻辑地址与物理地址的映射关系，但大型程序需要的页表非常大。现代系统使用多级页表来减少内存占用。比如，Linux中采用四级或五级页表结构。</span></li><li fid="u4f05c0a6" data-lake-id="u6192c822" id="u6192c822"><strong><span data-lake-id="ud566bb16" id="ud566bb16">交换（Swapping）</span></strong><span data-lake-id="u74c054e4" id="u74c054e4">：<br /></span><span data-lake-id="ue1db674e" id="ue1db674e">当物理内存不足时，操作系统将不常用的页面移到磁盘的交换区（Swap Space），释放内存给活跃的程序使用。</span></li></ol><h3 data-lake-id="sLJU0" id="sLJU0" data-lake-index-type="2"><span data-lake-id="ue49db4e3" id="ue49db4e3">Page Fault处理过程：</span></h3><ul list="u6b9a4811"><li fid="u642ad06e" data-lake-id="uf1cde1fc" id="uf1cde1fc"><span data-lake-id="u97df4d44" id="u97df4d44">CPU中断触发，保存上下文。</span></li><li fid="u642ad06e" data-lake-id="u00b9d61e" id="u00b9d61e"><span data-lake-id="u958dce00" id="u958dce00">操作系统从页表中判断所需页面位置。</span></li><li fid="u642ad06e" data-lake-id="uf42fd3bc" id="uf42fd3bc"><span data-lake-id="u4cf30804" id="u4cf30804">将页面从磁盘加载到内存，并更新页表。</span></li><li fid="u642ad06e" data-lake-id="u84fad26f" id="u84fad26f"><span data-lake-id="u17306d3c" id="u17306d3c">恢复上下文，继续执行。</span></li></ul><ol list="ub2bf93f3" start="4"><li fid="udb823bdc" data-lake-id="ucea24b74" id="ucea24b74"><strong><span data-lake-id="ua32a4400" id="ua32a4400">写时复制（Copy-On-Write, COW）</span></strong><span data-lake-id="u4e59cb03" id="u4e59cb03">：<br /></span><span data-lake-id="ue46f71f8" id="ue46f71f8">当多个进程共享相同的内存页（如fork时），只在发生写操作时才复制页面。这样可以显著减少内存占用。</span></li><li fid="udb823bdc" data-lake-id="ud6989697" id="ud6989697"><strong><span data-lake-id="ue8f7839a" id="ue8f7839a">虚拟内存与缓存一致性</span></strong><span data-lake-id="u591d86fa" id="u591d86fa">：<br /></span><span data-lake-id="u9b77d424" id="u9b77d424">虚拟内存引入了TLB（Translation Lookaside Buffer），用于加速逻辑地址到物理地址的映射。<br /></span><span data-lake-id="ubb03e19f" id="ubb03e19f">TLB是CPU缓存的一部分，存储最近使用的页表项。若TLB缺失，会触发页表查找。</span></li></ol><h2 data-lake-id="pFpZi" id="pFpZi" data-lake-index-type="2"><span data-lake-id="u59c1937d" id="u59c1937d" style="color: rgba(0, 0, 0, 0.88)">说下你常用的 Linux 命令？</span></h2><p data-lake-id="u7092b96b" id="u7092b96b"><br></p><p data-lake-id="u68c61f91" id="u68c61f91"><span data-lake-id="u22ca8570" id="u22ca8570" class="lake-fontsize-12" style="color: rgba(0, 0, 0, 0.85) !important">文件与目录操作:<br />・ls：列出当前目录的文件和子目录，常用参数如 -l（详细信息）、 -a（包括隐藏文件）。<br />・cd：切换目录，用于在文件系统中导航。<br />・mkdir：创建新目录。<br />・rm：删除文件或目录，用于删除文件时加上 -f 参数，删除目录时加上 -r 参数。<br />・cp：复制文件或目录，cp -r 用于递归复制目录。<br />・mv：移动或重命名文件或目录。</span><span data-lake-id="ue62eff82" id="ue62eff82" class="lake-fontsize-12" style="color: rgb(0, 0, 0)">​</span></p><p data-lake-id="ub599c450" id="ub599c450"><span data-lake-id="u8af00950" id="u8af00950" class="lake-fontsize-12" style="color: rgba(0, 0, 0, 0.85) !important">文件内容查看:<br />・cat：查看文件内容，常用于查看小型文本文件。<br />・more /less：分页查看文件内容，less 支持向上翻页，适合查看大文件。<br />・tail：查看文件末尾的若干行，tail -f 用于实时监控文件内容变化，如日志文件。<br />・head：查看文件的开头几行。</span></p><p data-lake-id="u20403b64" id="u20403b64"><span data-lake-id="ude4c1362" id="ude4c1362" class="lake-fontsize-12" style="color: rgba(0, 0, 0, 0.85) !important">系统管理:<br />・ps：显示当前运行的进程列表，ps aux 可以查看所有用户的进程。<br />・top /htop：实时查看系统中的进程状态和资源使用情况。<br />・kill /killall：终止进程，kill 后跟进程 ID，killall 后跟进程名。<br />・df：显示文件系统的磁盘使用情况。<br />・du：统计目录或文件所占用的磁盘空间，du -h 以人类可读的格式显示。</span></p><p data-lake-id="ua59d339d" id="ua59d339d"><span data-lake-id="u2aabcf13" id="u2aabcf13" class="lake-fontsize-12" style="color: rgba(0, 0, 0, 0.85) !important">网络配置与调试:<br />・ping：测试与目标主机的连通性。<br />・ifconfig /ip：查看和配置网络接口信息，ifconfig 已逐渐被 ip 命令替代。<br />・netstat /ss：查看网络连接和端口使用情况，ss 是 netstat 的替代品，提供更详细的信息。<br />・curl /wget：发送 HTTP 请求或下载文件，curl 更适合进行 API 调试，wget 则用于下载文件。</span></p><p data-lake-id="uf150624c" id="uf150624c"><span data-lake-id="ud79d9ee2" id="ud79d9ee2" class="lake-fontsize-12" style="color: rgba(0, 0, 0, 0.85) !important">文件权限与用户管理:<br />・chmod：修改文件或目录权限，常用模式如 chmod 755 。<br />・chown：更改文件或目录的所有者。<br />・useradd /userdel：添加或删除用户。<br />・passwd：修改用户密码。</span></p><h2 data-lake-id="lCoaA" id="lCoaA" data-lake-index-type="2"><span data-lake-id="u8e92e050" id="u8e92e050" style="color: rgba(0, 0, 0, 0.88)">什么是分段、什么是分页？</span></h2><p data-lake-id="u0d56b49e" id="u0d56b49e"><span data-lake-id="u2c0eb064" id="u2c0eb064">分段（Segmentation）和分页（Paging）是操作系统中用于内存管理的两种方式，目的是提高内存利用率并简化程序的管理。</span></p><p data-lake-id="u1cd74122" id="u1cd74122"><span data-lake-id="ufbacbe80" id="ufbacbe80" style="color: rgba(0, 0, 0, 0.88)">分段（Segmentation）：</span></p><ul list="u9db0f45c"><li fid="u5d1ebc1b" data-lake-id="u05bc1a05" id="u05bc1a05"><span data-lake-id="u3e0999e0" id="u3e0999e0" style="color: rgba(0, 0, 0, 0.88)">是一种根据程序逻辑结构划分内存的方式，例如将程序分为若干个段（如代码段、数据段、堆栈段等），每个段有独立的段号和段内偏移量。</span></li><li fid="u5d1ebc1b" data-lake-id="ucb1a74cd" id="ucb1a74cd"><span data-lake-id="u72a59f20" id="u72a59f20" style="color: rgba(0, 0, 0, 0.88)">每个段可以有不同的大小，段的长度取决于程序的实际需求，段与段之间可能不连续。 </span></li><li fid="u5d1ebc1b" data-lake-id="u49d4cecf" id="u49d4cecf"><span data-lake-id="u8cebd1b6" id="u8cebd1b6" style="color: rgba(0, 0, 0, 0.88)">分段管理提供了一种更贴近程序结构的内存管理方式，有助于提高程序的可读性和维护性。</span></li></ul><p data-lake-id="u27b03157" id="u27b03157"><span data-lake-id="ub4d85102" id="ub4d85102" style="color: rgba(0, 0, 0, 0.88)">分页（Paging）：</span></p><ul list="u6d9a2dda"><li fid="ude534e30" data-lake-id="u1078716a" id="u1078716a"><span data-lake-id="u523f6095" id="u523f6095" style="color: rgba(0, 0, 0, 0.88)">是一种将物理内存和逻辑内存划分为固定大小的页（Page）和页框（Frame）的方式，每个页和页框的大小相同。 </span></li><li fid="ude534e30" data-lake-id="u263835ec" id="u263835ec"><span data-lake-id="u1967a79a" id="u1967a79a" style="color: rgba(0, 0, 0, 0.88)">逻辑地址空间被划分为若干个固定大小的页，物理内存则被划分为相同大小的页框，页通过页表映射到页框。 </span></li><li fid="ude534e30" data-lake-id="ubd64ac99" id="ubd64ac99"><span data-lake-id="u790a1851" id="u790a1851" style="color: rgba(0, 0, 0, 0.88)">分页管理解决了内存碎片问题，但程序的逻辑结构和内存的物理结构不再一致。</span></li></ul><h2 data-lake-id="t9lDf" id="t9lDf" data-lake-index-type="2"><span data-lake-id="udb38577b" id="udb38577b" style="color: rgba(0, 0, 0, 0.88)">什么是软中断、什么是硬中断？</span></h2><p data-lake-id="ubd5063e6" id="ubd5063e6"><br></p><p data-lake-id="u74ba0a89" id="u74ba0a89"><span data-lake-id="ubf903ca9" id="ubf903ca9" style="color: rgb(28, 31, 35)">软中断和硬中断是操作系统处理外部或内部事件的两种中断方式： • 硬中断（Hardware Interrupt）：是由硬件设备（如键盘、网络卡、定时器等）触发的中断信号。当硬件设备需要与CPU交互（如数据传输完成、定时中断等），会通过硬中断通知CPU。硬中断具有高优先级，通常会立即打断当前执行的程序，进行中断处理。 • 软（件）中断（Software Interrupt）：是由软件（程序）触发的中断，通常是通过执行特定指令（如int指令）或系统调用产生的。软中断用于在程序运行中请求操作系统的服务，如文件读写、进程调度等。软中断的优先级一般低于硬中断。 </span></p><h3 data-lake-id="JFsCX" id="JFsCX" data-lake-index-type="2"><span data-lake-id="u223ab221" id="u223ab221" style="color: rgb(28, 31, 35)">软（件）中断和硬中断的区别</span></h3><h4 data-lake-id="iFC4P" id="iFC4P" data-lake-index-type="2"><span data-lake-id="uda92b4bc" id="uda92b4bc" style="color: rgb(28, 31, 35)">触发方式：</span></h4><ul list="ue4e75e71"><li fid="u7e7fc80e" data-lake-id="u255c9384" id="u255c9384"><span data-lake-id="u27d75e5b" id="u27d75e5b" style="color: rgb(28, 31, 35)">硬中断由外部硬件触发。</span></li><li fid="u7e7fc80e" data-lake-id="u0e801c33" id="u0e801c33"><span data-lake-id="u281e4785" id="u281e4785" style="color: rgb(28, 31, 35)">软中断由软件指令或程序逻辑触发。</span></li></ul><h4 data-lake-id="YfuUN" id="YfuUN" data-lake-index-type="2"><span data-lake-id="u831b9f20" id="u831b9f20" style="color: rgb(28, 31, 35)">优先级：</span></h4><ul list="u4a614780"><li fid="ue0ec9d43" data-lake-id="u747dcb92" id="u747dcb92"><span data-lake-id="u9ab81c33" id="u9ab81c33" style="color: rgb(28, 31, 35)">硬中断通常具有更高的优先级，会立即打断当前执行的任务进行处理。</span></li><li fid="ue0ec9d43" data-lake-id="u1e661292" id="u1e661292"><span data-lake-id="u4cfb3a6b" id="u4cfb3a6b" style="color: rgb(28, 31, 35)">软中断通常在硬中断处理完成后，操作系统根据优先级和调度策略进行处理。</span></li></ul><h4 data-lake-id="rMgVB" id="rMgVB" data-lake-index-type="2"><span data-lake-id="u241d521d" id="u241d521d" style="color: rgb(28, 31, 35)">应用场景：</span></h4><ul list="u9a85e623"><li fid="u09d54b6b" data-lake-id="ubf6accde" id="ubf6accde"><span data-lake-id="u05897e3c" id="u05897e3c" style="color: rgb(28, 31, 35)">硬中断用于实时性要求高的事件，如定时器中断、设备数据接收等。</span></li><li fid="u09d54b6b" data-lake-id="ufd996600" id="ufd996600"><span data-lake-id="u51b0a45d" id="u51b0a45d" style="color: rgb(28, 31, 35)">软中断用于程序请求操作系统服务或处理内部异常。</span></li></ul><h3 data-lake-id="t5qaL" id="t5qaL" data-lake-index-type="2"><span data-lake-id="u9e15d1bb" id="u9e15d1bb" style="color: rgb(28, 31, 35)">SoftIRQ软中断</span></h3><p data-lake-id="uea30805b" id="uea30805b"><span data-lake-id="uc8a66de7" id="uc8a66de7" style="color: rgb(28, 31, 35)">上述的软中断实际上称为软件中断比较合适，因为操作系统中有软中断（SoftIRQ）的概念，两者还是有所区别的。</span></p><p data-lake-id="u88ac487c" id="u88ac487c"><span data-lake-id="u9c372063" id="u9c372063" style="color: rgb(28, 31, 35)">软中断（SoftIRQ）是Linux内核中用于延迟处理部分中断任务的机制，属于中断处理的下半部。由于硬中断处理程序（上半部）需要尽可能短暂，以减少对系统的影响，因此将一些耗时的工作延迟到软中断中执行。即硬中断处理程序触发，然后内核在适当的时候调度执行。</span></p><p data-lake-id="ub214021f" id="ub214021f"><span data-lake-id="u9ffbe215" id="u9ffbe215" style="color: rgb(28, 31, 35)">内核维护一个软中断向量表，包含不同类型的软中断（如网络接收、网络发送、定时器等）。当需要触发软中断时，内核将相应的软中断标记为待处理状态，并在稍后的时间点（如在中断上下文退出时或在内核的调度点）执行这些软中断处理程序。</span></p><p data-lake-id="u58b52360" id="u58b52360"><span data-lake-id="u02f9ec7c" id="u02f9ec7c" style="color: rgb(28, 31, 35)">软中断（SoftIRQ）和软件中断（Software Interrupt）的区别如下：</span></p><ul list="u32cf7e1f"><li fid="uc368d6e6" data-lake-id="u89a2536f" id="u89a2536f"><span data-lake-id="u7ccbad51" id="u7ccbad51" style="color: rgb(28, 31, 35)">触发源不同：软件中断由用户程序通过指令触发；软中断通常由硬中断处理程序在内核中触发。</span></li><li fid="uc368d6e6" data-lake-id="udf09c03f" id="udf09c03f"><span data-lake-id="ue2e68d59" id="ue2e68d59" style="color: rgb(28, 31, 35)">目的不同：软件中断用于实现系统调用，提供用户态与内核态的接口；软中断用于延迟处理需要较长时间的中断任务，减少硬中断处理时间。 </span></li><li fid="uc368d6e6" data-lake-id="u47c59e2f" id="u47c59e2f"><span data-lake-id="u9d02177a" id="u9d02177a" style="color: rgb(28, 31, 35)">执行上下文不同：软件中断导致从用户态切换到内核态；软中断在内核态执行，不涉及用户态。</span></li></ul><h2 data-lake-id="jHkUp" id="jHkUp" data-lake-index-type="2"><span data-lake-id="u1c6268d3" id="u1c6268d3" style="color: rgba(0, 0, 0, 0.88)">线程和进程有什么区别？</span></h2><p data-lake-id="u6b6dae43" id="u6b6dae43"><span data-lake-id="u3bba8fac" id="u3bba8fac">进程：是资源分配的基本单位，每个进程都有自己独立的内存空间（代码段、数据段、堆栈等），可以看作是一个正在运行的程序实例。进程之间是相互独立的。</span></p><p data-lake-id="u559acfe9" id="u559acfe9"><span data-lake-id="u0705cec0" id="u0705cec0" style="color: rgba(0, 0, 0, 0.88)">线程：是CPU调度的基本单位，属于进程，一个进程中可以包含多个线程。线程共享进程的内存空间和资源（如文件句柄、数据段），但每个线程有自己独立的栈和寄存器。</span></p><h3 data-lake-id="PP6k6" id="PP6k6" data-lake-index-type="2"><span data-lake-id="ucbce06ec" id="ucbce06ec" style="color: rgba(0, 0, 0, 0.88)">其它区别：</span></h3><ul list="ub253cbcd"><li fid="uf7a21772" data-lake-id="ufb30510f" id="ufb30510f"><strong><span data-lake-id="u5c928937" id="u5c928937">资源消耗不同</span></strong><span data-lake-id="uf8aded71" id="uf8aded71" style="color: rgba(0, 0, 0, 0.88)">：进程时需要为其分配独立的内存空间和系统资源，创建和切换进程的开销较大。线程间共享进程的资源，创建线程所需的开销较小，线程切换的开销也远小于进程切换。</span></li><li fid="uf7a21772" data-lake-id="u39908770" id="u39908770"><strong><span data-lake-id="uecf73cd6" id="uecf73cd6">通信方式</span></strong><span data-lake-id="u762daa60" id="u762daa60" style="color: rgba(0, 0, 0, 0.88)">：因为各自独立的内存空间，进程间通信（IPC）较为复杂，需要使用管道、消息队列、共享内存、套接字等方式。同一进程内的线程共享内存空间，因此线程直接读写内存即可，但注意需要使用同步机制避免数据错误。</span></li></ul><h3 data-lake-id="M8964" id="M8964" data-lake-index-type="2"><span data-lake-id="uf626d8d1" id="uf626d8d1" style="color: rgba(0, 0, 0, 0.88)">扩展知识</span></h3><h4 data-lake-id="HdAsE" id="HdAsE" data-lake-index-type="2"><span data-lake-id="ue0248663" id="ue0248663" style="color: rgba(0, 0, 0, 0.88)">线程模型的演进</span></h4><ul list="ud9c3e517"><li fid="u4e4db743" data-lake-id="ud9937ec0" id="ud9937ec0"><strong><span data-lake-id="u943a903b" id="u943a903b">单线程模型</span></strong><span data-lake-id="ub424c2db" id="ub424c2db" style="color: rgba(0, 0, 0, 0.88)">：每个进程仅有一个线程，所有任务都在一个线程中顺序执行。适合简单的任务，但无法利用多核CPU的并行能力。</span></li><li fid="u4e4db743" data-lake-id="u356c77c0" id="u356c77c0"><strong><span data-lake-id="u3475a296" id="u3475a296">多线程模型</span></strong><span data-lake-id="u5842964f" id="u5842964f" style="color: rgba(0, 0, 0, 0.88)">：一个进程包含多个线程，可以利用多核CPU的并行执行能力，显著提升任务处理效率。 </span></li><li fid="u4e4db743" data-lake-id="u48a3d756" id="u48a3d756"><strong><span data-lake-id="u730c834c" id="u730c834c">线程池</span></strong><span data-lake-id="u787d33c8" id="u787d33c8" style="color: rgba(0, 0, 0, 0.88)">：线程池是为了避免频繁创建和销毁线程的开销，将一定数量的线程进行复用。常用于Web服务器、数据库连接池等场景，能够显著提升系统的性能和资源利用率。</span></li></ul><h4 data-lake-id="Z2q0W" id="Z2q0W" data-lake-index-type="2"><span data-lake-id="uc41fcb97" id="uc41fcb97" style="color: rgba(0, 0, 0, 0.88)">Linux创建进程和线程的方式</span></h4><ul list="u36c27735"><li fid="u20db902e" data-lake-id="u363b5e9d" id="u363b5e9d"><strong><span data-lake-id="u8efcda66" id="u8efcda66">创建进程</span></strong><span data-lake-id="u81916806" id="u81916806" style="color: rgba(0, 0, 0, 0.88)">：常用fork() 系统调用创建新进程，fork() 会复制调用它的进程，生成一个子进程。子进程与父进程共享代码段，但有独立的数据段和堆栈。 </span></li><li fid="u20db902e" data-lake-id="u39ba09d0" id="u39ba09d0"><strong><span data-lake-id="u14434e01" id="u14434e01">创建线程</span></strong><span data-lake-id="u500e17b6" id="u500e17b6" style="color: rgba(0, 0, 0, 0.88)">：使用pthread库中的pthread_create() 函数创建新线程。pthread库是POSIX标准下的多线程库，线程间共享进程的内存空间，但拥有各自的栈空间。</span></li></ul><h2 data-lake-id="IjIJt" id="IjIJt" data-lake-index-type="2"><span data-lake-id="uaaa81adc" id="uaaa81adc" style="color: rgba(0, 0, 0, 0.88)">进程之间的通信方式有哪些？</span></h2><p data-lake-id="u190c5ca2" id="u190c5ca2"><br></p><ol list="ufe802d3e"><li fid="u42606152" data-lake-id="uf4c7b7f7" id="uf4c7b7f7"><span data-lake-id="u19930887" id="u19930887">管道（Pipes）：管道是一种单向通信方式，用于在父进程和子进程之间或者同一主机上的不同进程之间传递数据。它可以是匿名的，也可以是命名的。</span></li><li fid="u42606152" data-lake-id="u87215738" id="u87215738"><span data-lake-id="ue75a3dd4" id="ue75a3dd4">命名管道（Named Pipes）：与匿名管道类似，但具有一个在文件系统中有名的路径，允许不相关的进程之间进行通信。 </span></li><li fid="u42606152" data-lake-id="udfa87397" id="udfa87397"><span data-lake-id="u323e19dc" id="u323e19dc">消息队列（Message Queues）：消息队列允许一个进程向另一个进程发送消息，消息在队列中按顺序存储，并且接收方可以按需接收。 </span></li><li fid="u42606152" data-lake-id="uca45993c" id="uca45993c"><span data-lake-id="ubeb1ddf0" id="ubeb1ddf0">共享内存（Shared Memory）：共享内存允许多个进程访问同一块内存区域，从而实现快速的数据交换。但需要注意同步问题，以避免竞态条件和数据一致性问题。 </span></li><li fid="u42606152" data-lake-id="u7a012aa8" id="u7a012aa8"><span data-lake-id="u2c0a7264" id="u2c0a7264">信号量（Semaphores）：信号量是一种同步原语，用于管理对共享资源的访问。它可以用于实现进程间的互斥访问和同步操作。 </span></li><li fid="u42606152" data-lake-id="ub911727d" id="ub911727d"><span data-lake-id="u81abc5e4" id="u81abc5e4">信号（Signal）：信号是一种异步的通信方式，用于通知目标进程发生了某个事件。信号常用于进程之间发送中断或终止命令。 </span></li><li fid="u42606152" data-lake-id="u2fb430e9" id="u2fb430e9"><span data-lake-id="u14ed5619" id="u14ed5619">套接字（Sockets）：套接字允许在网络上的不同主机上的进程进行通信，是实现网络通信的基础。 </span></li><li fid="u42606152" data-lake-id="ufef0d453" id="ufef0d453"><span data-lake-id="u629e1b60" id="u629e1b60">文件（File）：进程可以通过读写文件来进行通信，这种方式通常用于进程之间的间接通信，例如使用临时文件或者共享文件。</span></li></ol><h3 data-lake-id="s62A7" id="s62A7" data-lake-index-type="2"><span data-lake-id="u30d6a7bc" id="u30d6a7bc">扩展知识</span></h3><h4 data-lake-id="nZRZJ" id="nZRZJ" data-lake-index-type="2"><span data-lake-id="uff2c68dd" id="uff2c68dd">管道与命名管道的差异</span></h4><ul list="u1b6fbdcc"><li fid="u118c2109" data-lake-id="u85822d19" id="u85822d19"><strong><span data-lake-id="u4a911001" id="u4a911001">匿名管道</span></strong><span data-lake-id="u051acf69" id="u051acf69">：只能用于父子进程或兄弟进程之间的通信。匿名管道是单向的，数据从一端写入，从另一端读取。它简单易用，但局限于具有亲缘关系的进程。 </span></li><li fid="u118c2109" data-lake-id="u355f2c0b" id="u355f2c0b"><strong><span data-lake-id="ud90d6a93" id="ud90d6a93">命名管道（FIFO）</span></strong><span data-lake-id="u979e8007" id="u979e8007">：支持无亲缘关系的进程之间的通信。命名管道是一种存在于文件系统中的特殊文件，通过管道名称可以进行读写操作。适用于需要跨进程通信但不具备亲缘关系的场景。</span></li></ul><h4 data-lake-id="AWhWH" id="AWhWH" data-lake-index-type="2"><span data-lake-id="ub8aa46e5" id="ub8aa46e5">共享内存与同步机制</span></h4><p data-lake-id="u79c55c00" id="u79c55c00"><span data-lake-id="u175a4fd1" id="u175a4fd1">共享内存虽然能提供最快速的通信方式，但存在并发读写的问题，需要使用同步机制来控制：</span></p><ul list="uc35568ac"><li fid="u5be8bc9d" data-lake-id="u243b9db1" id="u243b9db1"><strong><span data-lake-id="uce29d399" id="uce29d399">信号量</span></strong><span data-lake-id="u65a96b6d" id="u65a96b6d">：用于对共享内存进行访问控制，防止多个进程同时读写时出现数据不一致。 </span></li><li fid="u5be8bc9d" data-lake-id="uef4b79ca" id="uef4b79ca"><strong><span data-lake-id="u1001da78" id="u1001da78">互斥锁（Mutex）和读写锁（Read - Write Lock）</span></strong><span data-lake-id="ua26fcac3" id="ua26fcac3">：用于解决多进程对共享资源的互斥访问问题，互斥锁确保只有一个进程可以访问共享资源，读写锁则允许多个进程进行读取操作，但在写操作时需要排他。</span></li></ul><h4 data-lake-id="nUHCm" id="nUHCm" data-lake-index-type="2"><span data-lake-id="u3b6bfd7e" id="u3b6bfd7e">套接字通信的分类与应用场景</span></h4><ul list="u83ee2411"><li fid="ub8e6ba2e" data-lake-id="u31f9ad0b" id="u31f9ad0b"><strong><span data-lake-id="u17619176" id="u17619176">本地套接字（UNIX域套接字）</span></strong><span data-lake-id="ua9b774c1" id="ua9b774c1">：用于同一台计算机上的进程通信，速度快且无需通过网络协议，是替代管道的更灵活的方式，适合需要传输大量数据的本地进程通信。 </span></li><li fid="ub8e6ba2e" data-lake-id="u0c383abb" id="u0c383abb"><strong><span data-lake-id="u3c29d772" id="u3c29d772">网络套接字（TCP/UDP）</span></strong><span data-lake-id="ub489f88e" id="ub489f88e">：用于不同计算机上的进程通信，通过网络协议传输数据。TCP套接字提供可靠的、面向连接的通信，保证数据包的顺序和完整性，适合文件传输、Web服务等场景。UDP套接字适合需要低延迟的场景，如实时音频视频传输，但不保证数据的可靠性。</span></li></ul><h4 data-lake-id="HBmHv" id="HBmHv" data-lake-index-type="2"><span data-lake-id="ua99e0795" id="ua99e0795">信号的使用与处理机制</span></h4><p data-lake-id="ub17ed5a0" id="ub17ed5a0"><span data-lake-id="u086483d6" id="u086483d6">信号是操作系统提供的一种通知机制，用于在进程间传递简单的通知信息。常见信号包括SIGKILL（强制终止进程）、SIGTERM（请求终止进程）、SIGUSR1和SIGUSR2（用户自定义信号）等。<br />信号是一种异步事件，进程无需主动等待信号到来，可以在任意时刻被信号中断。接收进程可以通过信号处理函数（Signal Handler）来处理接收到的信号。<br />在多进程服务中，可以通过信号来实现进程的优雅退出，或在调试过程中通过向进程发送信号来暂停、继续执行。</span></p><h2 data-lake-id="pvpOI" id="pvpOI" data-lake-index-type="2"><span data-lake-id="u29e7e3b9" id="u29e7e3b9" style="color: rgba(0, 0, 0, 0.88)">进程的调度算法你知道吗？</span></h2><h3 data-lake-id="yYcv7" id="yYcv7" data-lake-index-type="2"><span data-lake-id="uf607e7fb" id="uf607e7fb">最高响应比优先（HRRN）</span></h3><p data-lake-id="u4507e12f" id="u4507e12f"><span data-lake-id="u41e3e359" id="u41e3e359">HRRN调度算法通过计算每个进程的响应比来决定调度顺序。响应比的公式为：(等待时间 + 服务时间) / 服务时间 。其中，等待时间是进程在就绪队列中等待的时间，服务时间是进程预计需要的执行时间。通过这个公式，响应比会随着等待时间的增加而提升。</span></p><h4 data-lake-id="vioDs" id="vioDs" data-lake-index-type="2"><span data-lake-id="u0934922c" id="u0934922c">调度策略：</span></h4><ul list="ufee48439"><li fid="u3754dca9" data-lake-id="u90856933" id="u90856933"><span data-lake-id="uecf92619" id="uecf92619">对于短任务，其服务时间小，初始响应比就较高，容易被优先调度。</span></li><li fid="u3754dca9" data-lake-id="u12761348" id="u12761348"><span data-lake-id="u282837ed" id="u282837ed">对于长任务，随着等待时间的增加，响应比逐渐提升，最终也会被调度，避免了长任务的饥饿。</span></li></ul><h4 data-lake-id="GR70v" id="GR70v" data-lake-index-type="2"><span data-lake-id="u82e559af" id="u82e559af">优点：</span></h4><p data-lake-id="u66cf4e39" id="u66cf4e39"><span data-lake-id="u24646781" id="u24646781">HRRN能够在不完全了解执行时间的情况下，通过等待时间的增加来动态调整调度顺序。它在减少平均等待时间的同时，避免了短作业优先算法（SJF）中长任务被长期延迟的问题。</span></p><h4 data-lake-id="dDKg5" id="dDKg5" data-lake-index-type="2"><span data-lake-id="u7539040c" id="u7539040c">缺点：</span></h4><p data-lake-id="u16afff33" id="u16afff33"><span data-lake-id="u8abda1ad" id="u8abda1ad">相比于简单的FCFS和RR，HRRN的实现复杂度较高，因为需要持续计算并更新每个进程的响应比，适用于需要平衡长短任务的批处理系统，但在交互式系统中不常用。</span></p><h4 data-lake-id="SCris" id="SCris" data-lake-index-type="2"><span data-lake-id="u6f4f445c" id="u6f4f445c">应用场景：</span></h4><p data-lake-id="u2c763931" id="u2c763931"><span data-lake-id="u4bb3a3b5" id="u4bb3a3b5">HRRN 适合用于批处理环境，特别是在任务执行时间差距较大时，它能提供更公平的调度。比如在一些服务器负载较高的后台任务处理中，可以使用HRRN来确保所有任务都能被合理调度。</span></p><h3 data-lake-id="C92wi" id="C92wi" data-lake-index-type="2"><span data-lake-id="u90cf6bb5" id="u90cf6bb5">多级反馈队列调度（MLFQ）</span></h3><p data-lake-id="u1d324d82" id="u1d324d82"><span data-lake-id="u5faba671" id="u5faba671">MLFQ由多个优先级不同的队列组成，高优先级队列时间片较短，低优先级队列时间片较长。新到达的进程首先进入高优先级队列。</span></p><p data-lake-id="udadb0ede" id="udadb0ede"><span data-lake-id="u4f5408c6" id="u4f5408c6">如果进程在高优先级队列中未能在时间片内完成，则被移至低优先级队列。若进程被阻塞后恢复，就可以重新回到高优先级队列中。</span></p><ul list="u785c1602"><li fid="u8fa12741" data-lake-id="ue6810c27" id="ue6810c27"><strong><span data-lake-id="u16c23701" id="u16c23701">优点</span></strong><span data-lake-id="uf4f70150" id="uf4f70150">：能够灵活处理短任务与长任务，兼顾响应时间和吞吐量。</span></li><li fid="u8fa12741" data-lake-id="ud2780681" id="ud2780681"><strong><span data-lake-id="u241ec790" id="u241ec790">缺点</span></strong><span data-lake-id="u83f62c77" id="u83f62c77">：算法设计复杂，实现难度大，需要根据应用场景调整参数。</span></li></ul><h3 data-lake-id="qmuMy" id="qmuMy" data-lake-index-type="2"><span data-lake-id="u1f68cc6d" id="u1f68cc6d">时间片轮转（RR）的时间片选择</span></h3><p data-lake-id="u34ae1994" id="u34ae1994"><span data-lake-id="u57a9bc66" id="u57a9bc66">时间片越短，系统响应性越好，但上下文切换的次数增加，可能导致调度开销增大。时间片太长则会退化为先来先服务。</span></p><ul list="u9096211a"><li fid="uc12993f6" data-lake-id="ue476488f" id="ue476488f"><strong><span data-lake-id="ua42dd3df" id="ua42dd3df">应用场景</span></strong><span data-lake-id="u0fcf9e2e" id="u0fcf9e2e">：时间片轮转适合于交互式操作系统，如桌面系统和移动设备操作系统，能够确保所有用户程序都能在合理时间内获得CPU。</span></li></ul><p data-lake-id="u64195470" id="u64195470"><span data-lake-id="u59150e73" id="u59150e73"><br /> </span></p>